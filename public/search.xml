<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vuex简单概述]]></title>
    <url>%2F2019%2F01%2F30%2Fvuex%2F</url>
    <content type="text"><![CDATA[Vuex Vuex是什么？ 引入官方提供的解释，vuex 是专门为 vue.js 设计的一套 状态管理模式 。什么是状态管理模式？说白了就是数据的集中管理。我们在使用 vue.js 时所用到的数据全部抽取出来放在一个state对象下，这样我们在任何组件内都可以访问得到该数据。下面我们通过一个例子来看下 vuex 是如何管理我们的数据的。 首先先通过npm来安装一下vuex：npm install vuex --save state状态属性在项目src目录下新建一个store文件夹(该文件夹不是必须的，你也可以直接新建一个store.js，只要你引入的路径正确即可)，在该文件夹下新建一个 index.js。store文件夹主要是单独管理我们的数据状态，包括行为触发等等。 store/index.js import Vue from &#39;vue&#39; import Vuex from &#39;vuex&#39; Vue.use(Vuex) let store = new Vuex.Store({ state: { //要设置的全局访问的state对象 name: &quot;vuex&quot; } }) export default store 为了能在所有的组件中共享我们的数据，我们有必要给根实例下注入我们的store对象，所以我们在main.js文件中 main.js import Vue from &#39;vue&#39; import App from &#39;./App.vue&#39; import &quot;./commcss/index.scss&quot; import store from &#39;./store/index&#39; new Vue({ el: &#39;#app&#39;, render: h =&gt; h(App), store // 全局注册 }) App.vue &lt;template&gt; &lt;div class=&quot;app&quot;&gt; {{name}} &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { mapState} from &#39;vuex&#39; /* *1.mapState 辅助函数 *当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。 *为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键： */ export default { computde: { ...mapState([&#39;name&#39;]) } } &lt;/script&gt; Getter(store的计算属性，例如对列表进行过滤) store/index.js state: { count: 1, arr: [ { sex: &#39;男&#39;, id: 1 }, { sex: &#39;男&#39;, id: 2 }, { sex: &#39;男&#39;, id: 3 }, { sex: &#39;男&#39;, id: 4 }, { sex: &#39;女&#39;, id: 5 }, { sex: &#39;男&#39;, id: 6 }, { sex: &#39;男&#39;, id: 7 } ] }, getters: { man (state) { return state.arr.filter(item=&gt;{return item.sex===&#39;男&#39;}) } }, App.vue &lt;template&gt; &lt;div class=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(item,index) in man&quot; :key=&quot;item.id&quot;&gt;{{item.sex}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { mapGetters } from &#39;vuex&#39; //mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性： export default { computde: { ...mapGetters([&#39;man&#39;]) } } &lt;/script&gt; mutation(更新state的唯一方法) store/index.js mutation: { change (state) { state.name = &#39;vue&#39; } } App.vue &lt;template&gt; &lt;div class=&quot;app&quot; @click=&quot;change&quot;&gt; {{name}} &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { method: { change () { this.$store.commit(&#39;change&#39;) } } } &lt;/script&gt; 一条重要的原则就是要记住 mutation 必须是同步函数原因：(为什么不能执行一步操作) 现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。 因此：【我们需要一个action来进行异步操作】ActionAction 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 store/index.js state: { count: 0 }, mutations: { addcount (state) { state.count++ } }, actions: { getInfo (context) { setTimeout(()=&gt;{ context.commit(&#39;addcount&#39;) },2000) } } App.vue &lt;template&gt; &lt;div class=&quot;app&quot; @click=&quot;change&quot;&gt; {{count}} &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { computed: { ...mapState([&#39;count&#39;]) }, method: { change () { this.$store.dispatch(&#39;getInfo&#39;) } } } &lt;/script&gt; 乍一眼看上去感觉多此一举，我们直接分发 mutation 岂不更方便？实际上并非如此，还记得 mutation 必须同步执行这个限制么？Action 就不受约束！我们可以在 action 内部执行异步操作：Module由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。 为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：首先创建module/todo.js module/todo.js export default { namespaced: true, state: { count: 0 }, mutations: { addcount (state) { state.count++ } }, } store/index.js import todo from &quot;./modules/todo&quot; modules: { todo } App.vue &lt;template&gt; &lt;div class=&quot;app&quot; @click=&quot;change&quot;&gt; {{count}} &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { computed: { ...mapState(&#39;todo&#39;,[&#39;count&#39;]) }, method: { change () { this.$store.commit(&#39;todo/addcount&#39;) } } } &lt;/script&gt;]]></content>
      <tags>
        <tag>vue</tag>
        <tag>js</tag>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-router路由]]></title>
    <url>%2F2019%2F01%2F28%2FNew%20Router%2F</url>
    <content type="text"><![CDATA[路由路由传参(query,params)在单页面应用中路由的传递方式常用的两种方法、(query,params) query 包含在路径后面以？作为分割符，多参数直接使用&amp;分割开发，名字和值使用=分隔，这种方式适合传递不必须的值，传递和不传递都不会影响页面的加载 params 包含在路由路径之中，这种方式是框架内部的参数传递实现的，这种方式适合传递必须传递的值(/detail/:id) (/detail/11213),可以出现在路径中的任何位置 如何获取($router) 在vue中路由参数通过，$route获取，$route.params获取params传递的参数，$route.query获取query传递的参数，而$route就是代表的是当前页面的路由信息对象###而$router是获取的是路由实例，$route只是$router中一个参数的指针而已（） 常识： 1.router-link组件是用来跳转路由的，to属性是将要跳转的路由页地址。 2.router-view组件是用来展示组件页的。]]></content>
      <tags>
        <tag>vue-router</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue构造器及其实例化概念]]></title>
    <url>%2F2019%2F01%2F28%2Fvue%20extend%2F</url>
    <content type="text"><![CDATA[Vue构造器及其实例化概念 Vue构造器附官方文档 简单介绍 Vue.extend(options)参数: 对象用法: 使用Vue构造器，创建一个“子类”，参数是一个包含组件选项的对象，其中,data选项中必须是函数描述：Vue.extend返回的是一个“扩展实例构造器”，也就是预设了部分选项的Vue的实例构造器，它常常服务于Vue.component用来生成组件，可以简单理解为当在模板中遇到该组件作为标签的自定义元素时，会自动调用“扩展实例构造器”来生产组件实例，并挂在到自定义元素上 简单举例 自定义无参数标签下面的代码中的author就是返回的“扩展实例构造器” var author = Vue.extend({ template: &quot;&lt;p&gt;&lt;a :href=&#39;url&#39;&gt;{{author}}&lt;/a&gt;&lt;/p&gt;&quot;, data : function() { return { author : &#39;vamous&#39;, url : &#39;http://blog.csdn.net/Dear_Mr/article/details/72614370&#39; } } }); ###对应的html如下： &lt;author&gt;&lt;/author&gt; 此时的页面必然是没有任何效果的，因为扩展实例构造器还需要挂载，如下new author().$mount(&#39;author&#39;); 使用propsDatavar author = Vue.extend({ template: &quot;&lt;p&gt;&lt;a :href=&#39;url&#39;&gt;{{author}} &amp; {{name}}&lt;/a&gt;&lt;/p&gt;&quot;, data : function() { return { author : &#39;vamous&#39;, url : &#39;http://blog.csdn.net/Dear_Mr/article/details/72614370&#39; } }, props : [&#39;name&#39;] }); new author({propsData: {name : &#39;dear_mr&#39;}}).$mount(&#39;#author&#39;); 可以利用propsData传递参数挂载在普通标签上 返回的扩展实例构造器的方式和上面还是一样的，只是html里不再是自定义标签，而是一个普通标签，比如div &lt;div id=&quot;author&quot;&gt;&lt;/div&gt; new author().$mount(&#39;author&#39;); 其实对于同一个扩展构造器而言，它的每一个实例其实是可以挂载到不同的标签上的，比如我可以这样 new author().$mount(&#39;#author&#39;); new author().$mount(&#39;author&#39;); 这两个标签的内容会一同显示，结果一样 总结 Vue。extend(object)//扩展的子类需要Vue实例化才能使用，如果需要传递props，需要在new的时候通过propsData传递 $mount()手动执行组件的渲染，如果传递一个选择器，就会渲染选择器内部，如果传递只会生成dom不会执行渲染，需要手动将el挂载到页面 $destroy()手动销毁组件，但是如果将dom移动将不会销毁dom，需要手动销毁 $nextTick()生命周期updated的替代方案，因为在updated中只是得知组件需要重新渲染，但并不知道是哪个属性改变了，而nextTick()当属性改变并且渲染完成的回调，类似于react中的setState的回调函数 适用场景 使用扩展子类方式创建的组件适合开发使用api的方法调用 以上就是对Vue.extend构造器的实例详解]]></content>
      <tags>
        <tag>vue</tag>
        <tag>vue构造器</tag>
        <tag>vue extend</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Vue全局的扩展]]></title>
    <url>%2F2019%2F01%2F28%2Fvue%20block%2F</url>
    <content type="text"><![CDATA[关于Vue全局的扩展 Vue的全局组件我们平时使用组件，需要经过引入，绑定两个步骤。那么，如果我们需要使用一些全局组件或者第三方的组件库怎么办呢？在Vue官方文档中介绍的是使用Vue.component(tagName, options)来创建一个全局组件。但是这种方法是与根实例写在同一个文件中，如果要同时注册多个全局组件，就会使根实例文件过重，因此使用Vue.use()来“安装”全局组件，就显得更轻一些。方法： 1.新建一个plugins文件夹 2.在文件夹中创建放置全局组件的文件components.js 3.在components.js文件中引入所有要注册的全局组件 4.在app.js根实例文件中，引入components.js 以login组件为例login.jsimport Login from &#39;../components/eg.vue&#39;; export default (Vue)=&gt;{ Vue.component(&quot;Login&quot;,Login); } app.jsimport components from &#39;./plugins/components.js&#39;; Vue.use(components); 经过上述编写后，就注册了全局组件Login。Vue全局指令对于全局指令的注册，官方文档给出的方法是使用Vue.directive()，位置同样是在根实例文件下，那么问题来了，如果多个全局指令，再加上多个全局组件，那么app.js文件将变得臃肿无比。因此，同上面的注册全局组件方法相似，也是使用Vue.use()来“安装”全局指令。方法： 1.新建一个plugins文件夹 2.在文件夹中创建放置全局组件的文件directives.js 3.在directives.js文件中引入所有要注册的全局指令 4.在app.js根实例文件中，引入directives.js 以v-focus指令为例：directives.js: export default (Vue)=&gt;{ Vue.directive(&quot;focus&quot;,{ inserted:function(el){ el.focus(); } }) } app.jsimport directives from &quot;./plugins/directives.js&quot; Vue.use(directives); 这样就注册了全局指令扩展Vue类方法很简单再此不做更多描述…..直接看代码。》 。Vue.coke = function () { console.log(&quot;扩展了coke类方法&quot;) } 简单吧！！！！！扩展Vue原型，在vue组件中就可以通过this来访问废话不多说上代码Vue.prototype.$api = function () { console.log(&quot;扩展了$api方法&quot;) } ……………….Vue过滤器Vue.js允许自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和v-bind表达式。过滤器应该被添加在JavaScript表达式的尾部，由“管道”符号指示：|&lt;!-- 在双花括号中 --&gt; {{ message | capitalize }} &lt;!-- 在 `v-bind` 中 --&gt; &lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt; 可以在一个组件的选项中定义本地的过滤器：以截取手机为例filters: { phones (num) { let phoneStr = num.toString() let res = /(\d{1,})(\d{4})/ while (reg.test(phoneStr.replace)) { phoneStr = phoneStr.replace(reg, &#39;$1-$2&#39;) } return phoneStr } } //调用 {{17603446842 | phones}} //返回结果 176-0344-6842 全局过滤器Vue.filter(&quot;phones&quot;,function(num){ let phoneStr = num.toString() let res = /(\d{1,})(\d{4})/ while (reg.test(phoneStr.replace)) { phoneStr = phoneStr.replace(reg, &#39;$1-$2&#39;) } return phoneStr }) 来吧，举一个实用一点的例子上代码var app5 = new Vue({ el: &#39;#app5&#39;, data: { shoppingList: [ &quot;Milk&quot;, &quot;Donuts&quot;, &quot;Cookies&quot;, &quot;Chocolate&quot;, &quot;Peanut Butter&quot;, &quot;Pepto Bismol&quot;, &quot;Pepto Bismol (Chocolate flavor)&quot;, &quot;Pepto Bismol (Cookie flavor)&quot; ], key: &quot;&quot; }, computed: { filterShoppingList: function () { // `this` points to the vm instance var key = this.key; var shoppingList = this.shoppingList; //在使用filter时需要注意的是，前面调用的是需要使用filter的数组，而给filter函数传入的是数组中的每个item，也就是说filter里面的函数，是每个item要去做的，并将每个结果返回。 return shoppingList.filter(function (item) { return item.toLowerCase().indexOf(key.toLowerCase()) != -1 });; } } }) template &lt;ul&gt; Filter Key &lt;input type=&quot;text&quot; v-model=&quot;key&quot;&gt; &lt;li v-for=&quot;item in filterShoppingList&quot;&gt; {{ item }} &lt;/li&gt; &lt;/ul&gt; 最终效果实现了根据关键字来过滤列表的功能。]]></content>
      <tags>
        <tag>vue</tag>
        <tag>vue全局组件</tag>
        <tag>vue指令</tag>
        <tag>vue过滤器</tag>
        <tag>directive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue transfrom属性]]></title>
    <url>%2F2019%2F01%2F27%2Ftransition%2F</url>
    <content type="text"><![CDATA[Vue transfrom属性vue中的动画可以使用transfrom组件完成transfrom组件提供两个过渡状态 进入 enter 离开 leave 每个状态有三个步骤【自动添加类名 v代表的是transfrom组件上的name属性指定的值】 v-enter v-enter-active v-enter-to v-leave v-leave-active v-leave-to 通过结合css过渡动画和关键帧动画可以实现切换动画 动画触发场景 跟组件初始化渲染 v-show，v-if，component动态组件切换的时候 router-view 路由切换的时候 transfrom 组件还可以通过属性去改变不同状态自动添加的class类名 enter-active-class=”animated slideInDown” leave-active-class=”animated bounceOutDown” 这种方式适合配合第三方动画库实现动画&lt;transition v-on:before-enter=&quot;berforeEnter&quot; //可以做一些初始化样式设置 v-on:enter=&quot;enter&quot; //执行js操作dom完成的动画效果 v-on:after-enter=&quot;afterEnter&quot; //动画执行结束（也就是在enter中调用了done函数） v-on:enter-cancelled=&quot;enterCancelled&quot; 动画还没有结束，就执行下一次动画了，这时候不会触发动画结束，而是触发这个时间（取消） v-on:before-leave=&quot;beforeLeave&quot; v-on:leave=&quot;leave&quot; v-on:after-leave=&quot;afterLeave&quot; v-on:leave-cancelled=&quot;leaveCancelled&quot; &gt; &lt;!--...--&gt; &lt;/transition&gt;]]></content>
      <tags>
        <tag>vue</tag>
        <tag>transfrom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中的Dom操作]]></title>
    <url>%2F2019%2F01%2F27%2Fvue-dom%2F</url>
    <content type="text"><![CDATA[vue中的Dom操作在vue，react，。。。。以数据驱动视图的框架，都是通过数据更新视图，一般不使用dom操作，但是也有一些特定的时候需要用到dom操作dom操作的方法 transition:组件中的钩子函数可以接受一个el属性，作用动画的dom，可以多dom添加实现动画效果 ref：ref可以作用在dom元素和组件元素上，作用在dom元素上通过refs获取到就是dom节点，作用在组件元素上获取到组件实例 在mounted生命周期中我们可以使用document的dom的操作方法，比如添加一些滚动事件… #el：可以获取组件的根节点元素 ￥mount()：可以手动渲染组件，成为真实的dom节点 事件中的e.target可以获取都绑定事件的dom，但不准确，因为获取到的是点击最内层的元素，当然如果作用在表单元素就无所谓 指令也可以操作dom的]]></content>
      <tags>
        <tag>vue</tag>
        <tag>dom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码整洁之道：程序员的职业素养]]></title>
    <url>%2F2019%2F01%2F25%2Findex%2F</url>
    <content type="text"><![CDATA[代码整洁之道：程序员的职业素养 我们并非是因为喜欢和其他人在一起工作才选择做程序员的。我们都认为人际关系难以应付而且毫无规律。编程用的机器则整洁，行为也可预见。如果可以一个人待在房间里数个小时沉浸在一些真正有趣的问题上，那将会是最开心的时光。 以下全部内容均为本人2019年读书过程中所喜欢或者有感触的片段的摘录，来自于不同的书目，每本书标注了书名，书籍排序仅仅是阅读顺序（倒时间顺序），版权归原作者所有，这里仅作摘录整理。 阿加莎·克里斯蒂的真实人生 你无法创作命运，命运会不请自来，就是这么回事。 人人都做梦，但他们的梦不一样。 那些夜里在脏兮兮的脑袋瓜里做梦的人， 白天一觉醒来发现不过是虚幻一场； 要小心那些在白天做梦的人， 因为他们会睁大眼睛做梦， 用行动让梦想变成现实。 天真是一种罪过，冷漠是一种爱。律师以为自己操纵着游戏，但不过是他想加害的人手中的玩偶。 牧羊少年奇幻之旅 不管是牧羊人、海员，还是推销员，总会有一个地方令他们魂牵梦萦，那里会有一个人让他们忘记自由自在周游世界的快乐。 当总是面对同样的面孔，像在神学院里那样，就会渐渐让那些人成为生活的一部分。而由于他们是你生活的一部分，当然就想改变你的生活。如果你不像他们所期望的那样，他们就会不高兴。因为，对于该怎样生活，所有人都有固定的观念。但是他们对于自己该怎样生活却一头雾水，就像那个给人解梦、却不会把梦变成现实的老妇人。 男孩心想，人总会说一些刁钻古怪的事情。有的时候，最好与羊群为伴，羊群不声不响，只顾吃草和水晶。与书为伴也行，书总是在人们最想听故事的时候，告诉你一些意想不到的事情。但是，当人与人交谈的时候，有些人说的话会让我们无所适从，不知该怎样把谈话继续下去。「天命就是你一直期望去做的事情。人一旦步入青年时期，就知道什么是自己的天命了。在人生的这个阶段，一切都那么明朗，没有做不到的事情。人们敢于梦想，期待完成他们一生中喜欢做的一切事情。但是，随着时光的流逝，一股神秘的力量开始企图证明，根本不可能实现天命。」实际上，每天都一成不变，是因为人们已经失去了对美好事物的敏锐感觉。我和别人没什么两样：总是以理想的眼光看待世界，以为事情会按理想的方式发展，而不会用现实的眼光看待世界，看不到事情真相。「因为麦加是支撑我活下去的希望，使我能够忍受平庸的岁月，忍受橱柜里那些不会说话的水晶，忍受那间糟糕透顶的餐厅里的午饭和晚饭。我害怕实现我的梦想，实现之后，我就没有活下去的动力了。」「你的梦想是羊群和金字塔。你与我不同，因为你希望实现你的梦想，而我只是想保有去麦加的梦想。我曾无数次地想象过，如何穿过沙漠，到达安放着圣石的广场，在触摸圣石之前，围着它绕行七圈。我曾想象过有些人站在我身旁，有些人站在我前面，还有我们的谈话和共同的祈祷。可是，我担心会大失所望，所以我宁愿只保留一个梦想。」「你一度成为我的福音。而今天我明白了一个道理，任何不被接纳的福音，都会变成诅咒。我对生活没有更多的要求。而你正迫使我盯着从未见过的财富和前景。现在，我知道了这些财富和前景，也知道了我完全有可能拥有它们。可是我的感觉却比以前糟糕了。因为我知道我自己可以拥有这一切，却不愿拥有它们。」别的事情不好说，但在这件事上，男孩坚信不疑，尽管他的父母以及先辈都说过，必须在恋爱、订婚、相互了解和有了钱之后才可以结婚。说这话的人大概从来不了解宇宙的语言，因为如果掌握了这种语言，很容易就能理解，世上总有人在等待着另外一个人，无论是在大沙漠还是在大城市。当这两个人最终相遇，四目相对的时候，过去的一切和将来的一切全都变得无足轻重了，只有眼前的这一刻最重要。因为生活永远是，也仅仅是我们现在经历的这一刻。这正是需要爱发挥力量的地方，因为当我们有爱的时候，总是希望自己变得更好。 且听风吟 说到底，写文章并非自我诊治的手段，充其量不过是自我疗养的一种小小的尝试。问题是，直言不讳是件极为困难的事。甚至越是想直言不讳，直率的言语越是遁入黑暗的深处。死去的祖母常说「心情抑郁的人只能做抑郁的梦，要是更加抑郁的，连梦都不做的。」如果你志在追求艺术追求文学，那么去读一读希腊人写的东西好了。因为要诞生真正的艺术，奴隶制度是必不可少的。而古希腊人便是这样：奴隶们耕种、烧饭、划船，而市民们则在地中海的阳光下陶醉于吟诗作赋，埋头于数学解析。所谓艺术便是这么一种玩意儿。至于半夜三点半在悄无声息的厨房寻找电冰箱里的食品的人，只能写出这等模样的文章。而那就是我。「我时常想：假如活着不给任何人添麻烦该有多好！你说能做到吗？」「怎么说呢，大概因为厌烦了吧。可我也在尽我的努力——就连自己都难以置信。我也在考虑别人，像考虑自己的事一样，也因此挨过警察的揍。但到时候人们终究要各归其位，唯独我无处可归，就像玩『抢椅子』游戏没了椅子。」「不过你认真想想看：条件大伙都一样，就像同坐一架出了故障的飞机。诚然，有的运气好些，有的运气差些，有的坚强些有的懦弱些，有的有钱有的没钱。但没有一个家伙怀有超乎常人的自信，大家一个样，拥有什么的家伙生怕一旦失去，一无所有的家伙担心永远一无所有，大家一个样。所以，早些察觉到这一点的人 应该力争使自己多少怀有自信，哪怕装模做样也好，对吧？什么自信之人，那样的人根本没有，有的不过是能够装出自信的人。」「把谁都知道的事写成小说，那究竟有何意味可言？」我有时说谎。最后一次说谎是在去年。说谎是非常令人讨厌的勾当。不妨说，说谎与沉默是现代人类中流行的两大罪过。我们实际上经常说谎，也往往沉默不语。然而，倘若我们一年四季都喋喋不休，而且喋喋不休的无不真实，那么真实的价值必然荡然无存。 超能力侦探事务所 和事件无关的人，只要时间够久，或有新的事件发生，就会很快忘记过往的事。世界上永远没有「感同身受」这件事，因为没有亲身经历，无法体会到当事人的痛苦。]]></content>
  </entry>
  <entry>
    <title><![CDATA[px2rem 移动端自适应方案]]></title>
    <url>%2F2019%2F01%2F25%2Fpx2rem%2F</url>
    <content type="text"><![CDATA[1/25/2019 4:36:42 PM px2remvue-cli中如何使用px2rem实际开发中，我们通过设计稿得到的值单位是 px，所以要将 px 转换成 rem 再写进样式中。将 px 转换成 rem 我们将使用 px2rem 这个工具，它有 webpack 的 loader：px2rem-loader安装 px2rem-loader在命令行中运行如下安装：npm i px2rem-loader --save-dev 配置 px2rem-loader1/25/2019 4:36:17 PM 在 vue-cli 生成的 webpack 配置中，vue-loader 的 options 和其他样式文件 loader 最终是都是由 build/utils.js 里的一个方法生成的。我们只需在 cssLoader 后再加上一个 px2remLoader 即可，px2rem-loader 的 remUnit 选项意思是 1rem=多少像素，结合 lib-flexible 的方案，我们将 px2remLoader 的 options.remUnit 设置成设计稿宽度的 1/10，这里我们假设设计稿宽为 750px。// utils.js var cssLoader = { loader: &#39;css-loader&#39;, options: { sourceMap: options.sourceMap } } var px2remLoader = { loader: &#39;px2rem-loader&#39;, options: { remUnit: 75 } } 并放进 loaders 数组中// utils.js function generateLoaders(loader, loaderOptions) { var loaders = [cssLoader, px2remLoader] } 也可以动态的根据可视窗口的大小来设置[在这里写一个计算]const size = 200 const screen = 375 const flexFn = () =&gt; { const windowWidth = window.outerWidth const ratio = windowWidth / screen const newSize = ratio * (size / 2) document.querySelector(&#39;html&#39;).style.fontSize = newSize + &quot;px&quot; } flexFn() window.addEventListener(&quot;resize&quot;, () =&gt; { flexFn() },false) 直接将该js引入到main.js中即可 修改配置后需要重启，然后我们在组件中写单位直接写 px，设计稿量多少就可以写多少了，舒服多了。]]></content>
      <tags>
        <tag>vue</tag>
        <tag>js</tag>
        <tag>vue-cli</tag>
        <tag>px2rem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue概述]]></title>
    <url>%2F2019%2F01%2F25%2Fvue%2F</url>
    <content type="text"><![CDATA[1/25/2019 4:34:55 PM 此文章只是对VUE常用的知识进行了一个简述，详情请访问官方文档 什么是vue？vue是一个框架(渐进式开发框架),其实就是一个框架的名称，其特点是(数据双向绑定，组件开发，单页面路由，指令，插件)什么叫渐进式框架通过开发组件的形式，进行组件的组件的组合，来组合出来的一个页面而已最重要的特性就是组件组件类似于模块，设计组建的目的是为了更好的解耦业务，和模块化的区别就在于(组件的组成包含了(结构，逻辑，样式))而模块只是逻辑组件的特性 组建的状态(data,props) 组件和组件的通讯 自己的生命周期 组件的渲染和组件的创建方式 组件的创建方式 vue.component(componnetName,option) (自动渲染) 在每一个组件中都有component选项，用来注册局部组件 (自动渲染) 通过Vue.extends()扩展子类的形式创建 (手动渲染) 组建的实例选项 @[function] data @[object] method @[object] compoted @[object] watch @[object] conponents @[function] 生命周期 beforeCreated(){}//初始化数据之前 created () {} //数据初始化之后 beforeMout () {} //开始渲染 mounted () {} //渲染完成 beforeUpdate () {} //开始更新 当一个数据的改变引起了视图的重新的渲染才会执行，单独的一个数据改变是不会执行的 uppdated() {} //更新完成 //当使用keep-alive组件时才会 执行 activated //组件启用时 deactivated //组件停用时 //组件销毁 v-if销毁组件，或者切换路由(在没有启用缓存的前提)，或者手动执行this.$destroy().清理组件中绑定的data，通过v-on绑定事件，如果有手动绑定的内容需要，在这个生命周期中手动销毁 beforeDestroy destroyed //当组件中发生错误时 errorCaptured ) 组件的通讯方式通讯创建：父子，子父，同级，跨级通讯其实就是谁用谁的数据 父子：子组件使用父组件数据，props(常用)，子组件内部通过$parent 子父：父组件使用子组件数据，通过自定事件，子组件通过$emit(事件名称，发送数据)给父组件传递数据(常用)$children $refs 同级：代理(一个子组件将数据发送到父级，父在发送到另一个子级)，eventBus vuex 跨级：逐层传递，vuex eventsBus 组件的嵌套组件内部通过slot内置组件，可以用来承载嵌套组件(单个slot，和命名slot)内置组件 template 单文件组件中代替了template选项，可以用作一个包裹元素，不会被渲染 component 动态组件，通过is属性动态渲染某一个组件 slot 插槽，用来承载组件潜逃的子组件 transition vue用来实现动画的组件(提供了，进入和离开两个状态) transitions-group 用来实现多动画(列表动画，排序，添加，删除) keep-alive 用来启动vue缓存功能，缓存组件的状态 vue的实例属性实例属性 vm.$data //访问定义的data vm.$props //访问props对象 vm.$el //访问组件的根节点 vm.$options //访问所有配置项 vm.$parent //访问父组件实例 vm.$root vm.$children vm.$slots vm.$scopedSlots vm.$refs vm.$isServer vm.$attrs vm.$listeners 实例方法 / 数据 vm.$watch vm.$set vm.$delete 实例方法 / 事件 vm.$on vm.$once vm.$off vm.$emit 实例方法 / 生命周期 vm.$mount vm.$forceUpdate vm.$nextTick //数据改变后回调 vm.$destroy //手动渲染]]></content>
      <tags>
        <tag>vue</tag>
        <tag>js</tag>
        <tag>vue概述</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sass基本语法使用]]></title>
    <url>%2F2018%2F08%2F04%2Fsass%2F</url>
    <content type="text"><![CDATA[1/26/2019 10:54:49 AM sass学过CSS的人都知道，它不是一种编程语言。你可以用它开发网页样式，但是没法用它编程。也就是说，CSS基本上是设计师的工具，不是程序员的工具。在程序员眼里，CSS是一件很麻烦的东西。它没有变量，也没有条件语句，只是一行行单纯的描述，写起来相当费事。基本语法 变量SASS允许使用变量，所有变量以$开头。 $blue : #1875e7; div { color : $blue; } 如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中。 $side : left; .rounded { border-#{$side}-radius: 5px; } 计算功能SASS允许在代码中使用算式： body { margin: (14px/2); top: 50px + 100px; right: $var * 10%; } 嵌套SASS允许选择器嵌套。比如，下面的CSS代码： div h1 { color : red; } 可以写成： div { hi { color:red; } } 代码的重用 【继承】 SASS允许一个选择器，继承另一个选择器。比如，现有class1： .class1 { border: 1px solid #ddd; } class2要继承class1，就要使用@extend命令： .class2 { @extend .class1; font-size:120%; } MixinMixin有点像C语言的宏（macro），是可以重用的代码块。使用@mixin命令，定义一个代码块。 @mixin left { float: left; margin-left: 10px; } 使用@include命令，调用这个mixin。 div { @include left; } mixin的强大之处，在于可以指定参数和缺省值。 @mixin left($value: 10px) { float: left; margin-right: $value; } 使用的时候，根据需要加入参数： div { @include left(20px); } 下面是一个mixin的实例，用来生成浏览器前缀。 @mixin rounded($vert, $horz, $radius: 10px) { border-#{$vert}-#{$horz}-radius: $radius; -moz-border-radius-#{$vert}#{$horz}: $radius; -webkit-border-#{$vert}-#{$horz}-radius: $radius; } 使用的时候，可以像下面这样调用： .navbar li { @include rounded(top, left); } .footer { @include rounded(top, left, 5px); } 插入文件@import命令，用来插入外部文件。 @import &quot;path/filename.scss&quot;; 如果插入的是.css文件，则等同于css的import命令。 @import &quot;foo.css&quot;; 高级用法 ### 1. 条件语句 #### @if可以用来判断： p { @if 1 + 1 == 2 { border: 1px solid; } @if 5 &lt; 3 { border: 2px dotted; } } #### 配套的还有@else命令： @if lightness($color) &gt; 30% { background-color: #000; } @else { background-color: #fff; } ### 2. 循环语句 #### SASS支持for循环： @for $i from 1 to 10 { .border-#{$i} { border: #{$i}px solid blue; } } #### 也支持while循环： $i: 6; @while $i &gt; 0 { .item-#{$i} { width: 2em * $i; } $i: $i - 2; } #### each命令，作用与for类似： @each $member in a, b, c, d { .#{$member} { background-image: url(&quot;/image/#{$member}.jpg&quot;); } } ### 3. 自定义函数 #### SASS允许用户编写自己的函数。 @function double($n) { @return $n * 2; } #sidebar { width: double(5px); }]]></content>
      <tags>
        <tag>css</tag>
        <tag>scss</tag>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue slot-scope的理解（适合初学者）]]></title>
    <url>%2F2018%2F08%2F04%2Fvue%20slot-scope%2F</url>
    <content type="text"><![CDATA[Vue slot-scope的理解（适合初学者） 1/26/2019 2:58:04 PM Vue中关于插槽的文档说明很短，语言又写的很凝练，再加上其和方法，数据，计算机等常用选项在使用频率，使用先后上的差别，这就有可能造成初次接触插槽的开发者容易产生“算了吧，回头再学，反正已经可以写基础组件了”的想法，于是就关闭了VUE的说明文档。 实际上，插槽的概念很简单 slot 概念：插槽，也就是槽，是组件的一块HTML模板，这块模板显示不显示，以及怎样显示由父组件来决定。 插槽可以分为3部分来说 单个插槽 首先是单个插槽，单个插槽的英文VUE的官方叫法，但是其实也可以叫它默认插槽，或者与具名插槽相对，我们可以叫它匿名插槽。因为它不用设置名称属性。 单个插槽可以放置在组件的任意位置，但是就像它的名字一样，一个组件中只能有一个该类插槽。相对应的，具名插槽就可以有很多个，只要名字（名称属性）不同就可以了。 下面通过一个例子来展示。 父组件： &lt;div class=&quot;slot-righ&quot;&gt; &lt;p&gt;22222&lt;/p&gt; &lt;Slo&gt; &lt;div class=&quot;con&quot;&gt; 111111 &lt;/div&gt; &lt;/Slo&gt; &lt;/div&gt; 子组件： &lt;div class=&quot;sol&quot;&gt; &lt;p&gt;11111&lt;/p&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; 具名插槽 匿名插槽没有名称属性，所以是匿名插槽，那么，插槽加了名称属性，就变成了具名插槽。具名插槽可以在一个组件中出现Ñ次，出现在不同的位置。下面的例子，一个就是有两个具名插槽状语从句：单个插槽的组件，这三个插槽被父组件用同一套的CSS样式显示了出来，不同的是内容上略有区别。 下面通过一个例子来展示。 父组件： &lt;div class=&quot;slot-righ&quot;&gt; &lt;p&gt;22222&lt;/p&gt; &lt;Slo&gt; &lt;div class=&quot;con&quot; slot=&quot;up&quot;&gt; 111111 &lt;/div&gt; &lt;/Slo&gt; &lt;/div&gt; 子组件： &lt;div class=&quot;sol&quot;&gt; &lt;p&gt;11111&lt;/p&gt; &lt;slot name=&quot;up&quot;&gt;&lt;/slot&gt;//具名插槽 &lt;/div&gt; 作用域插槽| 带数据的插槽 最后，就是我们的作用域插槽。这个稍微难理解一点。官方叫它作用域插槽，实际上，对比前面两种插槽，我们可以叫它带数据的插槽。什么意思呢，就是前面两种，都是在组件的模板里面写 下面通过一个例子来展示。 父组件： &lt;div class=&quot;slot-righ&quot;&gt; &lt;p&gt;22222&lt;/p&gt; &lt;Slo&gt; &lt;div class=&quot;con&quot; slot-scope=&quot;user&quot;&gt;//父组件拿到数据 {{user.data}} &lt;/div&gt; &lt;/Slo&gt; &lt;/div&gt; 子组件： &lt;template&gt; &lt;div class=&quot;sol&quot;&gt; &lt;p&gt;11111&lt;/p&gt; &lt;slot :data=&quot;data&quot;&gt;&lt;/slot&gt;//这里再插槽上绑定数据 &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data(){ return { data:11111111 } } } &lt;/script&gt; 正因为作用域插槽绑定了一套数据，父组件可以拿来用于是，情况就变成了这样：样式父组件说了算，但内容可以显示子组件插槽绑定的。]]></content>
      <tags>
        <tag>vue</tag>
        <tag>js</tag>
        <tag>slot</tag>
      </tags>
  </entry>
</search>
